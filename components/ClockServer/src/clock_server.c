/*
 * Copyright 2019, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */

#include <assert.h>
#include <stdint.h>
#include <stdbool.h>

#include <camkes.h>
#include <camkes/io.h>
#include <platsupport/clock.h>
#include <utils/util.h>

typedef struct clock_entry {
    bool initialised;
    seL4_Word owner;
    clk_t *clk;
} clock_entry_t;

static ps_io_ops_t ops;
static clock_entry_t *clock_table;

/* Prototypes for these functions are not generated by the camkes templates yet */
seL4_Word the_clock_get_sender_id(void);

static inline bool check_clk_initialised(clk_id_t clk_id)
{
    return clock_table[clk_id].initialised;
}

static inline bool check_valid_clk_id(clk_id_t clk_id)
{
    return (clk_id >= 0 && clk_id < NCLOCKS);
}

static inline bool check_valid_clock_gate(clock_gate_t clock_gate)
{
    return (clock_gate >= 0 && clock_gate <= NCLKGATES);
}

static inline bool check_is_owner(clk_id_t clk_id, seL4_Word client_id)
{
    return (clock_table[clk_id].owner == client_id);
}

static inline seL4_Word get_client_id(void)
{
    /* We subtract one as the IDs start from 1 to avoid using the zero badge.
     * The zero badge makes it difficult to distinguish that the client with
     * this badge sent us a request among the other clients. */
    assert(the_clock_get_sender_id() > 0);
    return the_clock_get_sender_id() - 1;
}

int the_clock_init_clock(clk_id_t clk_id)
{
    ZF_LOGF_IF(clock_lock(), "Failed to lock the clock server");

    int error = 0;

    if (!check_valid_clk_id(clk_id)) {
        error = EINVAL;
        goto out;
    }

    seL4_Word client_id = get_client_id();

    if (check_clk_initialised(clk_id)) {
        if (!check_is_owner(clk_id, client_id)) {
            error = EBUSY;
            goto out;
        } else {
            error = 0;
            goto out;
        }
    }

    clock_table[clk_id].clk = clk_get_clock(&ops.clock_sys, clk_id);
    if (!clock_table[clk_id].clk) {
        error = ENODEV;
        goto out;
    }

    clock_table[clk_id].initialised = true;
    clock_table[clk_id].owner = client_id;

out:
    ZF_LOGF_IF(clock_unlock(), "Failed to unlock the clock server");
    return error;
}

int the_clock_set_gate_mode(clock_gate_t gate, clock_gate_mode_t mode)
{
    ZF_LOGF_IF(clock_lock(), "Failed to lock the clock server");

    /* TODO Some basic form of access control to the gates?,
     * Don't want a component to turn off the clock underneath another component */
    int error = clk_gate_enable(&ops.clock_sys, gate, mode);

    ZF_LOGF_IF(clock_unlock(), "Failed to unlock the clock server");
    return error;
}

freq_t the_clock_get_freq(clk_id_t clk_id)
{
    ZF_LOGF_IF(clock_lock(), "Failed to lock the clock server");

    freq_t freq = 0;

    if (!check_valid_clk_id(clk_id)) {
        freq = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id();

    if (!check_clk_initialised(clk_id)) {
        freq = 0;
        goto out;
    }

    if (!check_is_owner(clk_id, client_id)) {
        freq = 0;
        goto out;
    }

    freq = clk_get_freq(clock_table[clk_id].clk);

out:
    ZF_LOGF_IF(clock_unlock(), "Failed to unlock the clock server");
    return freq;
}

freq_t the_clock_set_freq(clk_id_t clk_id, freq_t hz)
{
    ZF_LOGF_IF(clock_lock(), "Failed to lock the clock server");

    freq_t set_freq = 0;

    if (!check_valid_clk_id(clk_id)) {
        set_freq = 0;
        goto out;
    }

    seL4_Word client_id = get_client_id();

    if (!check_clk_initialised(clk_id)) {
        set_freq = 0;
        goto out;
    }

    if (!check_is_owner(clk_id, client_id)) {
        set_freq = 0;
        goto out;
    }

    set_freq = clk_set_freq(clock_table[clk_id].clk, hz);

out:
    ZF_LOGF_IF(clock_unlock(), "Failed to unlock the clock server");
    return set_freq;
}

int the_clock_register_child(clk_id_t parent, clk_id_t child)
{
    ZF_LOGF_IF(clock_lock(), "Failed to lock the clock server");

    int error = 0;

    if (!check_valid_clk_id(parent) || !check_valid_clk_id(child)) {
        error = EINVAL;
        goto out;
    }

    seL4_Word client_id = get_client_id();

    if (!check_clk_initialised(parent)) {
        error = EPERM;
        goto out;
    }

    if (!check_is_owner(parent, client_id)) {
        error = EPERM;
        goto out;
    }

    if (!check_clk_initialised(child)) {
        error = EPERM;
        goto out;
    }

    if (!check_is_owner(child, client_id)) {
        error = EPERM;
        goto out;
    }

    clk_register_child(clock_table[parent].clk, clock_table[child].clk);
    error = 0;

out:
    ZF_LOGF_IF(clock_unlock(), "Failed to unlock the clock server");
    return error;
}

void post_init(void)
{
    int error = clock_lock();
    ZF_LOGF_IF(error, "Failed to lock clock server");

    error = camkes_io_ops(&ops);
    ZF_LOGF_IF(error, "Failed to get camkes_io_ops");

    error = clock_sys_init(&ops, &ops.clock_sys);
    ZF_LOGF_IF(error, "Failed to initialise the clock subsystem");

    error = ps_calloc(&ops.malloc_ops, 1, sizeof(*clock_table) * NCLOCKS, (void **) &clock_table);
    ZF_LOGF_IF(error, "Failed to allocate memory for the clock table");

    error = clock_unlock();
    ZF_LOGF_IF(error, "Failed to unlock clock server");
}
